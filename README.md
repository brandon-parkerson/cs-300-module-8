# cs-300-module-8
## What was the problem you were solving in the projects for this course?

This course focused on exploring diverse data models, such as binary trees, hash tables, and linked lists, and determining their optimal application within software systems. The challenge lay in identifying the most efficient and effective structure for each specific problem domain.

## How did you approach the problem? Consider why data structures are important to understand.

I took a systematic approach, analyzing the inherent strengths and limitations of each data structure. By evaluating their performance characteristics and alignment with the task at hand, I ensured that the chosen structure maximized efficiency and minimized drawbacks. This strategic understanding is vital as data structures are the foundation of robust and scalable software solutions.

## How did you overcome any roadblocks you encountered while going through the activities or project?

When faced with challenges, I leveraged official documentation to gain a deeper understanding of specific methods and their implementations. Additionally, I reviewed practical examples to solidify my comprehension. In some cases, I constructed simplified prototype code to test and validate my logic before scaling it into more complex designs, fostering a structured and iterative problem-solving process.

## How has your work on this project expanded your approach to designing software and developing programs?

Engaging in Big-O analysis profoundly enhanced my awareness of performance considerations and algorithmic efficiency. It compelled me to adopt a more deliberate approach to design, prioritizing scalability and optimization. Furthermore, I recognized a gap in my ability to think recursively, which I now view as an area for growth in enhancing the sophistication of my designs.

## How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

Experience has underscored the importance of modular design and reusable components. For instance, I have refined commonly used file stream functions into versatile prototypes. Moving forward, I plan to formalize additional frequently used elements into dedicated libraries, promoting maintainability, readability, and adaptability in future projects.
